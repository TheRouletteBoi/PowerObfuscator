#ifndef __POWEROBFUSCATOR_H__
#define __POWEROBFUSCATOR_H__

#include <types.h>
#include <stdint.h>
#include <string>
#undef vector
#include <vector>
#include <sys/process.h>
#include <libpsutil.h>

/* symbols generated by the linker! */
extern unsigned char const __start__Ztext[];
extern unsigned char const __start__Zdata[];
extern unsigned char const __start__Zrodata[];

#define STATIC_ALWAYS_INLINE    static inline   __attribute__((always_inline))
#define NO_STATIC_ALWAYS_INLINE inline          __attribute__((always_inline))
#define NO_INLINE                               __attribute__((noinline))

#define POBF_MAGIC 'P', 'O', 'B', 'F'
#define POBF_SIGNATURE 0xAABBCCDD, 0x12345678, 0xEEFFEEFF 
/* these values will be replaced by the real values using PowerObfuscatorGUI */
#define POBF_TEXT_SEGMENT_DUMMY_VALUES 0xDEADBEEF, 0x0BADCAFE, 0x00DDBA11 
#define POBF_DATA_SEGMENT_DUMMY_VALUES 0x5CA1AB1E, 0x0DEC0DED, 0x00EFFEC7 
#define POBF_PLACEHOLDER_DUMMY_VALUES1 0x5E1EC7ED, 0x05EEDBED, 0x05CABB1E 
#define POBF_PLACEHOLDER_DUMMY_VALUES2 0x00FF5E75, 0x0001ABE1, 0x000F100D 

namespace pobf
{
    struct opd_s
    {
        uint32_t func;
        uint32_t toc;
    };

    struct Pattern
    {
        const char* find;
        const char* mask;
        bool found;
    };

    struct pobfHeader
    {
        char magic[4];
        uint32_t signature1;
        uint32_t signature2;
        uint32_t signature3;
        uint32_t textSegmentStart;
        uint32_t textSegmentSize;
        uint32_t _padding1;
        uint32_t dataSegmentStart;
        uint32_t dataSegmentSize;
        uint32_t _padding2;
        uint32_t rodataSegmentStart;
        uint32_t rodataSegmentSize;
        uint32_t _padding3;
        uint32_t placeHolder1;
        uint32_t placeHolder2;
        uint32_t _padding4;
        char placeHolder5[60];
    };

    extern pobfHeader pobf_header;

    namespace Segment
    {
        STATIC_ALWAYS_INLINE sys_pid_t _sys_process_getpid()
        {
            system_call_0(SYS_PROCESS_GETPID);
            return_to_user_prog(sys_pid_t);
        }

        STATIC_ALWAYS_INLINE uint32_t _sys_dbg_write_process_memory(sys_pid_t pid, void* destination, const void* source, size_t size)
        {
            system_call_4(905, (uint64_t)pid, (uint64_t)destination, (uint64_t)size, (uint64_t)source);
            return_to_user_prog(uint32_t);
        }

        STATIC_ALWAYS_INLINE uint32_t _ps3mapi_write_process_memory(sys_pid_t pid, void* destination, const void* source, size_t size)
        {
            system_call_6(8, 0x7777, 0x32, (uint64_t)pid, (uint64_t)destination, (uint64_t)source, (uint64_t)size);
            return_to_user_prog(uint32_t);
        }

        STATIC_ALWAYS_INLINE void _write_process_memory(void* destination, const void* source, size_t size)
        {
            static bool usePs3mapiSyscalls = false;

            if (!usePs3mapiSyscalls)
            {
                uint32_t write = _sys_dbg_write_process_memory(_sys_process_getpid(), destination, source, size);
                if (write == SUCCEEDED)
                    return;
            }

            usePs3mapiSyscalls = true;
            _ps3mapi_write_process_memory(_sys_process_getpid(), destination, source, size);
        }

        STATIC_ALWAYS_INLINE uint32_t FindEndOfMain(uint32_t mainAddress, uint32_t textSegmentEnd)
        {
            uint32_t found = 0;
            for (uint32_t i = mainAddress; i < textSegmentEnd; i++)
            {
                // find end of function by searching for 'blr' instruction 4E 80 00 20
                if (*(uint32_t*)(i) == 0x4E800020)
                {
                    found = i + 3;
                    break;
                }
            }

            return found;
        }

        STATIC_ALWAYS_INLINE bool SkipLast2Bytes(uint32_t iterator)
        {
            // from 0 to 3
            bool isThirdByte = (iterator % 4) == 2;
            bool isFourthByte = (iterator % 4) == 3;

            if (isThirdByte || isFourthByte)
                return true;

            return false;
        }

        STATIC_ALWAYS_INLINE bool SkipInstructionsWithStringOrPointerReference(uint32_t textSegmentStart, uint32_t textSegmentEnd, uint32_t mainStart, uint32_t mainEnd, uint32_t offsetToCompare)
        {
            // in powerpc64 instructions are 4 bytes in length
            for (uint32_t i = textSegmentStart; i < textSegmentStart; i += 4)
            {
                // Skip the main() function
                if (i >= mainStart && i <= mainEnd)
                    continue;

                uint32_t entireInstruction = *(uint32_t*)(i);
                uint8_t opCode = entireInstruction >> 24; // get the first byte of the instruction

#if 0
                const uint8_t skipOpCodes[] = {
                    0x30,   // addic
                    0x3C,   // lis
                    0x80,   // lwz
                    //0x61,   // ori
                    //0x64,   // oris
                };
#endif

                if (opCode == 0x30 // addic
                    || opCode == 0x3C // lis
                    || opCode == 0x80) // lwz
                {
                    // TODO(Roulette): save offset of the last 2 bytes in the instruction
                    // ...
                }
            }


            // TODO(Roulette): skip the last 2 bytes of the instruction 
            // ...

            return false;
        }

        template <class T>
        STATIC_ALWAYS_INLINE void DecryptSegments(T mainFn)
        {
            uint32_t textSegment = (uint32_t)&__start__Ztext[0];
            uint32_t dataSegemnt = (uint32_t)&__start__Zdata[0];
            uint32_t rodataSegment = (uint32_t)&__start__Zrodata[0];
            //uint32_t moduleBaseAddress = textSegment;

            /* decrypt .data segment */
            uint32_t dataSegmentStart = dataSegemnt;
            uint32_t dataSegmentEnd = dataSegemnt + pobf_header.dataSegmentSize;

            uint32_t headerStart = (uint32_t)&pobf_header;
            uint32_t headerEnd = headerStart + sizeof(pobfHeader) + 3;

            // Replace this key with the one provided by PowerObfuscatorGUI
            static uint8_t encryptionKey[64] = { 0x24, 0x0A, 0x04, 0x11, 0x06, 0x2A, 0x11, 0x12, 0x01, 0x16, 0x10, 0x15, 0x00, 0x0A, 0x01, 0x24, 0x1B, 0x12, 0x16, 0x06, 0x3B, 0x07, 0x15, 0x01, 0x07, 0x06, 0x12, 0x00, 0x1B, 0x17, 0x23, 0x1B, 0x03, 0x00, 0x01, 0x3B, 0x16, 0x03, 0x06, 0x07, 0x17, 0x04, 0x07, 0x1B, 0x06, 0x35, 0x1C, 0x03, 0x11, 0x17, 0x3C, 0x16, 0x12, 0x10, 0x00, 0x17, 0x15, 0x11, 0x1C, 0x06, 0x24, 0x0A, 0x04, 0x11 };

            for (uint32_t i = dataSegmentStart; i < dataSegmentEnd; i++)
            {
                // skip pobf_header
                if (i >= headerStart && i <= headerEnd)
                    continue;

                // read 1 byte at a time
                uint8_t byte = *(uint8_t*)(i);

                //uint8_t unencryptedByte = byte ^ 0x69;
                uint8_t unencryptedByte = (byte ^ encryptionKey[(i - dataSegmentStart) % sizeof(encryptionKey)]);
                //printf("encryptedByte 0x%X unencryptedByte 0x%02X at 0x%X\n", byte, unencryptedByte, i);

                _write_process_memory((void*)i, &unencryptedByte, sizeof(uint8_t));
            }


            /* decrypt .rodata segment */
            uint32_t rodataSegmentStart = rodataSegment;
            uint32_t rodataSegmentEnd = rodataSegment + pobf_header.rodataSegmentSize;

            for (uint32_t i = rodataSegmentStart; i < rodataSegmentEnd; i++)
            {
                // read 1 byte at a time
                uint8_t byte = *(uint8_t*)(i);

                //uint8_t unencryptedByte = byte ^ 0x69;
                uint8_t unencryptedByte = (byte ^ encryptionKey[(i - rodataSegmentStart) % sizeof(encryptionKey)]);
                //printf("encryptedByte 0x%X unencryptedByte 0x%02X at 0x%X\n", byte, unencryptedByte, i);

                _write_process_memory((void*)i, &unencryptedByte, sizeof(uint8_t));
            }


            /* decrypt .text segment */
            uint32_t textSegmentStart = textSegment;
            uint32_t textSegmentEnd = textSegment + pobf_header.textSegmentSize;

            uint32_t mainStart = ((pobf::opd_s*)mainFn)->func;
            uint32_t mainEnd = FindEndOfMain(mainStart, textSegmentEnd);

            for (uint32_t i = textSegmentStart; i < textSegmentEnd; i++)
            {
                // skip the main() function
                if (i >= mainStart && i <= mainEnd)
                    continue;

#if 0
                if (SkipInstructionsWithStringOrPointerReference(textSegmentStart, textSegmentEnd, mainStart, mainEnd, i))
                    continue;
#endif

                if (SkipLast2Bytes(i))
                    continue;

                // read 1 byte at a time
                uint8_t byte = *(uint8_t*)(i);

                //uint8_t unencryptedByte = byte ^ 0x69;
                uint8_t unencryptedByte = (byte ^ encryptionKey[(i - textSegmentStart) % sizeof(encryptionKey)]);
                //printf("encryptedByte 0x%X unencryptedByte 0x%02X at 0x%X\n", byte, unencryptedByte, i);

                _write_process_memory((void*)i, &unencryptedByte, sizeof(uint8_t));
            }
        }
    }

    namespace Encrypt
    {
        /***
        * mr     r4, r4
        * rlwinm r31, r31, 0, 0x1E, 0x1E
        * mr     r5, r5
        *
        * NOTE(Roulette): _16 means marker is 16 bytes long
        */
        #define FUNCTION_MARKER_START_16 0x7C842378, 0x57FF07BC, 0x7CA52B78
        #define FUNCTION_MARKER_START_16_ASM() \
                    __asm("mr     r4, r4;"                      /* \x7C\x84\x23\x78 */    \
                          "rlwinm r31, r31, 0, 0x1E, 0x1E;"     /* \x57\xFF\x07\xBC */    \
                          "mr     r5, r5;");                    /* \x7C\xA5\x2B\x78 */

        /***
        * mr     r5, r5
        * rlwinm r31, r31, 0, 0x1E, 0x1E
        * mr     r4, r4
        *
        * NOTE(Roulette): _16 means which marker is 16 bytes long
        */
        #define FUNCTION_MARKER_END_16 0x7CA52B78, 0x57FF07BC, 0x7C842378
        #define FUNCTION_MARKER_END_16_ASM() \
                    __asm("mr     r5, r5;"                      /* \x7C\xA5\x2B\x78 */    \
                          "rlwinm r31, r31, 0, 0x1E, 0x1E;"     /* \x57\xFF\x07\xBC */    \
                          "mr     r4, r4;");                    /* \x7C\x84\x23\x78 */

        /***
        * xor r3, r3, r4
        * xor r3, r3, r4
        */
        #define FUNCTION_MARKER_START_XOR_8 0x7C6322787C632278
        #define FUNCTION_MARKER_START_XOR_8_ASM() \
                    __asm("xor %r3, %r3, %r4;"       /* \x7C\x63\x22\x78 */     \
                            "xor %r3, %r3, %r4;");   /* \x7C\x63\x22\x78 */

        /***
        * xor r3, r3, r5
        * xor r3, r3, r5
        */
        #define FUNCTION_MARKER_END_XOR_8 0x7C632A787C632A78
        #define FUNCTION_MARKER_END_XOR_8_ASM() \
                    __asm("xor %r3, %r3, %r5;"       /* \x7C\x63\x2A\x78 */     \
                            "xor %r3, %r3, %r5;");   /* \x7C\x63\x2A\x78 */

        /***
        * xor r3, r3, r6
        * xor r3, r3, r6
        */
        #define FUNCTION_MARKER_START_XOR2_8 0x7C6332787C633278
        #define FUNCTION_MARKER_START_XOR2_8_ASM() \
                    __asm("xor %r3, %r3, %r6;"       /* \x7C\x63\x32\x78 */     \
                            "xor %r3, %r3, %r6;");   /* \x7C\x63\x32\x78 */

        /***
        * xor r3, r3, r7
        * xor r3, r3, r7
        */
        #define FUNCTION_MARKER_END_XOR2_8 0x7C633A787C633A78
        #define FUNCTION_MARKER_END_XOR2_8_ASM() \
                    __asm("xor %r3, %r3, %r7;"       /* \x7C\x63\x3A\x78 */     \
                            "xor %r3, %r3, %r7;");   /* \x7C\x63\x3A\x78 */

        /***
        * lis r3, 0xFFEE
        * ori r3, r3, 0xDDCC
        */
        #define FUNCTION_MARKER_START_FFEEDDCC_8 0x3C60FFEE6063DDCC
        #define FUNCTION_MARKER_START_FFEEDDCC_8_ASM() \
                    __asm("lis %r3, 0xFFEE;"          /* \x3C\x60\xFF\xEE */    \
                            "ori %r3, %r3, 0xDDCC;"); /* \x60\x63\xDD\xCC */

        /***
        * lis r3, 0xFFEE
        * ori r3, r3, 0xDDCD
        */
        #define FUNCTION_MARKER_END_FFEEDDCD_8 0x3C60FFEE6063DDCD
        #define FUNCTION_MARKER_END_FFEEDDCD_8_ASM() \
                    __asm("lis %r3, 0xFFEE;"          /* \x3C\x60\xFF\xEE */    \
                            "ori %r3, %r3, 0xDDCD;"); /* \x60\x63\xDD\xCD */

        /***
        * mr r4, r4
        * mr r5, r5
        *
        * NOTE(Roulette): _8 means marker is 8 bytes long
        */
        #define FUNCTION_MARKER_START_MR_8 0x7C8423787CA52B78
        #define FUNCTION_MARKER_START_MR_8_ASM() \
                    __asm("mr r4, r4;"       /* \x7C\x84\x23\x78 */             \
                            "mr r5, r5;");   /* \x7C\xA5\x2B\x78 */

        /***
        * mr r5, r5
        * mr r4, r4
        *
        * NOTE(Roulette): _8 means marker is 8 bytes long
        */
        #define FUNCTION_MARKER_END_MR_8 0x7CA52B787C842378
        #define FUNCTION_MARKER_END_MR_8_ASM() \
                            __asm("mr r5, r5;"       /* \x7C\xA5\x2B\x78 */     \
                                    "mr r4, r4;");   /* \x7C\x84\x23\x78 */

        /***
        * mr r4, r4
        *
        * NOTE(Roulette): _4 means marker is 4 bytes long
        */
        #define FUNCTION_MARKER1_INDIVIDUAL_4 0x7C842378

        /***
        * mr r5, r5
        *
        * NOTE(Roulette): _4 means marker is 4 bytes long
        */
        #define FUNCTION_MARKER2_INDIVIDUAL_4 0x7CA52B78



        template<int A, int C, int M>
        class LowRandom
        {
        public:
            LowRandom(uint32_t seed) : m_Seed(seed) {}

            uint32_t Next()
            {
                return m_Seed = (A * m_Seed + C) % M;
            }

        private:
            uint32_t m_Seed;
        };


        // EG: RealTimeFunctionEncrypt<decltype(&main)> encrypt(main);
        template <class T>
        class RealTimeFunctionEncrypt
        {
        public:
            NO_STATIC_ALWAYS_INLINE RealTimeFunctionEncrypt(T function) 
                : m_FunctionAddress(((pobf::opd_s*)function)->func), m_EncryptionStart(0), m_EncryptionEnd(0), m_Erase(false)
            {
                FindMarkers();
                Decrypt();
                FUNCTION_MARKER_START_XOR_8_ASM();
            }

            /***
            * Constructor with an option to erase the function after use
            */
            NO_STATIC_ALWAYS_INLINE RealTimeFunctionEncrypt(T function, bool erase)
                : m_FunctionAddress(((pobf::opd_s*)function)->func), m_EncryptionStart(0), m_EncryptionEnd(0), m_Erase(erase)
            {
                FindMarkers();
                Decrypt();
                FUNCTION_MARKER_START_XOR_8_ASM();
            }

            NO_STATIC_ALWAYS_INLINE ~RealTimeFunctionEncrypt()
            {
                FUNCTION_MARKER_END_XOR_8_ASM();
                Encrypt();

                if (m_Erase)
                    Erase();
            }


        private:
            /***
            * @breif Find the encryption markers within the function
            *
            */
            void FindMarkers()
            {
                printf("%s\n", __FUNCTION__);

                if (!m_FunctionAddress)
                    return;

                uint64_t* read2Instructions = (uint64_t*)m_FunctionAddress;
                printf("read2Instruction 0x%X\n", read2Instructions);

                for (uint32_t i = 0; i < maxFunctionScanSize; i++)
                {
                    printf("read2Instruction in %d = 0x%016llX\n", i, read2Instructions[i]);
                    if (read2Instructions[i] == FUNCTION_MARKER_START_XOR_8)
                    {
                        m_EncryptionStart = m_FunctionAddress + (i * 4);
                        printf("Found encryption start at 0x%X\n", m_EncryptionStart);

                    }
                    else if (read2Instructions[i] == FUNCTION_MARKER_END_XOR_8)
                    {
                        m_EncryptionEnd = m_FunctionAddress + (i * 4) + markerSize;
                        printf("found encryption end at 0x%X\n", m_EncryptionEnd);

                        break;
                    }
                }


                printf("Failed to find encryption in function 0x%X\n", m_FunctionAddress);
            }

            /***
            * @brief Check's if function has encryption markers
            * @param maxFunctionSize estimated function size to find markers
            */
            bool HasMarker(uint32_t maxFunctionSize)
            {
                if (!m_FunctionAddress)
                    return false;

                uint64_t* readInstruction = (uint64_t*)m_FunctionAddress;

                for (uint32_t i = 0; i < maxFunctionSize; i++)
                {
                    if (readInstruction[i] == FUNCTION_MARKER_START_XOR_8)
                        return true;
                }

                return false;
            }

            void Encrypt()
            {
                if (!m_EncryptionStart)
                    return;

                for (uint32_t i = m_EncryptionStart; i < m_EncryptionEnd; i++)
                {
                    uint8_t byte = *(uint8_t*)(i);

                    uint8_t encryptedByte = byte ^ 0x69;

                    pobf::Segment::_write_process_memory((void*)i, &encryptedByte, sizeof(uint8_t));
                }
            }

            void Decrypt()
            {
                if (!m_EncryptionStart)
                    return;

                for (uint32_t i = m_EncryptionStart; i < m_EncryptionEnd; i++)
                {
                    uint8_t byte = *(uint8_t*)(i);

                    uint8_t unencryptedByte = byte ^ 0x69;

                    pobf::Segment::_write_process_memory((void*)i, &unencryptedByte, sizeof(uint8_t));
                }
            }

            void Erase()
            {
                if (!m_EncryptionStart)
                    return;

                for (uint32_t i = m_EncryptionStart - markerSize; i < m_EncryptionEnd + markerSize; i++)
                {
#if 0
                    LowRandom<0x11111111, 0x66666666, 0x7FFFFFFF> random(vxRAND()); // use compile time random as the seed
                    uint32_t randomByte = random.Next();
#endif

                    uint8_t nullByte = 0x00;
                    pobf::Segment::_write_process_memory((void*)i, &nullByte, sizeof(uint8_t));
                }
            }


        private:
            uint32_t m_FunctionAddress;
            uint32_t m_EncryptionStart;
            uint32_t m_EncryptionEnd;
            bool m_Erase; /* Whether or not to erase the function after use. This cannot be undone. */

            static const unsigned maxFunctionScanSize = 0x1000; /* Only scan 0x1000 bytes of a function. If you have more than that, it's not supported */
            static const unsigned markerSize = 8; /* Size of the encryption marker in bytes */
        };
    }

    namespace DumpObfuscation
    {
        enum Type : uint32_t
        {
            LisR3 = 1 << 0,
            LisR4 = 1 << 1,
            LisR5 = 1 << 2,
            LisR6 = 1 << 3,
            LisR7 = 1 << 4,
            XorR3 = 1 << 5,
            XorR4 = 1 << 6,
            XorR5 = 1 << 7,
            XorR6 = 1 << 8,
            XorR7 = 1 << 9
        };

        /**
        * @brief set the eboot start and end address
        * @note This function must be called before any of the other DumpObfuscation functions
        */
        void SetEbootRange(uint32_t ebootStartAddress, uint32_t ebootEndAddress);

        /**
        * @brief Replaces all 'li r3, 0' instructions with 'lis r3, 0'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceLisR3();

        /**
        * @brief Replaces all 'li r4, 0' instructions with 'lis r4, 0'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceLisR4();

        /**
        * @brief Replaces all 'li r5, 0' instructions with 'lis r5, 0'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceLisR5();

        /**
        * @brief Replaces all 'li r6, 0' instructions with 'lis r6, 0'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceLisR6();

        /**
        * @brief Replaces all 'li r7, 0' instructions with 'lis r7, 0'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceLisR7();

        /**
        * @brief Replaces all 'li r3, 0' instructions with 'xor r3, r5, r5'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceXorR3();

        /**
        * @brief Replaces all 'li r4, 0' instructions with 'xor r4, r5, r5'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceXorR4();

        /**
        * @brief Replaces all 'li r5, 0' instructions with 'xor, r5, r5, r5'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceXorR5();

        /**
        * @brief Replaces all 'li r6, 0' instructions with 'xor r6, r5, r5'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceXorR6();

        /**
        * @brief Replaces all 'li r7, 0' instructions with 'xor, r7, r5, r5'
        * @note If anyone tries to dump the game memory they will need to replace all these instruction in the dump if compared to the original eboot.
        * All this does is slow down the attacker.
        */
        void ReplaceXorR7();

        /**
        * @brief Replace instructions by type. Using enum DumpObfuscation::Type
        */
        void ReplaceByType(uint32_t type);
    }

    namespace String_Vx
    {
        // https://stackoverflow.com/questions/7270473/compile-time-string-encryption
        // http://www.rohitab.com/discuss/topic/39611-malware-related-compile-time-hacks-with-c11/

        //-------------------------------------------------------------//
        // "Malware related compile-time hacks with C++11" by LeFF	 //
        // You can use this code however you like, I just don't really //
        // give a shit, but if you feel some respect for me, please	//
        // don't cut off this comment when copy-pasting... ;-)		 //
        //-------------------------------------------------------------//

        #ifdef _WINDOWS
        #define ALWAYS_INLINE __forceinline
        #else
        #define ALWAYS_INLINE __attribute__((always_inline))
        #endif


        #ifndef vxCPLSEED
        // If you don't specify the seed for algorithms, the time when compilation
        // started will be used, seed actually changes the results of algorithms...
        #define vxCPLSEED ((__TIME__[7] - '0') * 1	+ (__TIME__[6] - '0') * 10  + \
                    (__TIME__[4] - '0') * 60   + (__TIME__[3] - '0') * 600 + \
                    (__TIME__[1] - '0') * 3600 + (__TIME__[0] - '0') * 36000)
        #endif

        // The constantify template is used to make sure that the result of constexpr
        // function will be computed at compile-time instead of run-time
        template <uint32_t Const> struct vxCplConstantify { enum { Value = Const }; };

        // Compile-time mod of a linear congruential pseudorandom number generator,
        // the actual algorithm was taken from "Numerical Recipes" book
        constexpr uint32_t vxCplRandom(uint32_t Id)
        {
            return (1013904223 + 1664525 * ((Id > 0) ? (vxCplRandom(Id - 1)) : (vxCPLSEED))) & 0xFFFFFFFF;
        }

        // Compile-time random macros, can be used to randomize execution  
        // path for separate builds, or compile-time trash code generation
        #define vxRAND()		   (pobf::String_Vx::vxCplConstantify<pobf::String_Vx::vxCplRandom(__COUNTER__ + 1)>::Value)
        #define vxRANDOM(Min, Max) (Min + (vxRAND() % (Max - Min + 1)))
        

        // Compile-time recursive mod of string hashing algorithm,
        // the actual algorithm was taken from Qt library (this
        // function isn't case sensitive due to vxCplTolower)
        constexpr char	 vxCplTolower(char Ch) { return (Ch >= 'A' && Ch <= 'Z') ? (Ch - 'A' + 'a') : (Ch); }
        constexpr uint32_t vxCplHashPart3(char Ch, uint32_t Hash) { return ((Hash << 4) + vxCplTolower(Ch)); }
        constexpr uint32_t vxCplHashPart2(char Ch, uint32_t Hash) { return (vxCplHashPart3(Ch, Hash) ^ ((vxCplHashPart3(Ch, Hash) & 0xF0000000) >> 23)); }
        constexpr uint32_t vxCplHashPart1(char Ch, uint32_t Hash) { return (vxCplHashPart2(Ch, Hash) & 0x0FFFFFFF); }
        constexpr uint32_t vxCplHash(const char* Str) { return (*Str) ? (vxCplHashPart1(*Str, vxCplHash(Str + 1))) : (0); }

        // Compile-time generator for list of indexes (0, 1, 2, ...)
        template <uint32_t...> struct vxCplIndexList {};
        template <typename	IndexList, uint32_t Right> struct vxCplAppend;
        template <uint32_t... Left, uint32_t Right> struct vxCplAppend<vxCplIndexList<Left...>, Right> { typedef vxCplIndexList<Left..., Right> Result; };
        template <uint32_t N> struct vxCplIndexes { typedef typename vxCplAppend<typename vxCplIndexes<N - 1>::Result, N - 1>::Result Result; };
        template <> struct vxCplIndexes<0> { typedef vxCplIndexList<> Result; };

        // Compile-time string encryption of a single character
        const unsigned char vxCplEncryptCharKey = vxRANDOM(0, 0xFF);
        constexpr char vxCplEncryptChar(const char Ch, uint32_t Idx) { return Ch ^ (vxCplEncryptCharKey + Idx); }

        // Compile-time string encryption class
        template <typename IndexList> struct vxCplEncryptedString;
        template <uint32_t... Idx>	struct vxCplEncryptedString<vxCplIndexList<Idx...> >
        {
            char Value[sizeof...(Idx) + 1]; // Buffer for a string

            // Compile-time constructor
            constexpr inline vxCplEncryptedString(const char* const Str)
                : Value{ vxCplEncryptChar(Str[Idx], Idx)... } {}

            // Run-time decryption
            char* decrypt()
            {
                for (uint32_t t = 0; t < sizeof...(Idx); t++)
                {
                    this->Value[t] = this->Value[t] ^ (vxCplEncryptCharKey + t);
                }
                this->Value[sizeof...(Idx)] = '\0';
                return this->Value;
            }
        };
    }

    namespace String_ADVobfuscator
    {
        // https://github.com/andrivet/ADVobfuscator


        // std::index_sequence will be available with C++14 (C++1y). For the moment, implement a (very) simplified and partial version. You can find more complete versions on the Internet
        // MakeIndex<N>::type generates Indexes<0, 1, 2, 3, ..., N>
        template<int... I>
        struct Indexes { using type = Indexes<I..., sizeof...(I)>; };

        template<int N>
        struct Make_Indexes { using type = typename Make_Indexes<N - 1>::type::type; };

        template<>
        struct Make_Indexes<0> { using type = Indexes<>; };





        // Very simple compile-time random numbers generator.

        // For a more complete and sophisticated example, see:
        // http://www.researchgate.net/profile/Zalan_Szgyi/publication/259005783_Random_number_generator_for_C_template_metaprograms/file/e0b49529b48272c5a6.pdf

        namespace
        {
            // I use current (compile time) as a seed

            constexpr char time[] = __TIME__; // __TIME__ has the following format: hh:mm:ss in 24-hour time

            // Convert time string (hh:mm:ss) into a number
            constexpr int DigitToInt(char c) { return c - '0'; }
            const int seed = DigitToInt(time[7]) +
                DigitToInt(time[6]) * 10 +
                DigitToInt(time[4]) * 60 +
                DigitToInt(time[3]) * 600 +
                DigitToInt(time[1]) * 3600 +
                DigitToInt(time[0]) * 36000;
        }

        // 1988, Stephen Park and Keith Miller
        // "Random Number Generators: Good Ones Are Hard To Find", considered as "minimal standard"
        // Park-Miller 31 bit pseudo-random number generator, implemented with G. Carta's optimization:
        // with 32-bit math and without division

        template<int N>
        struct MetaRandomGenerator
        {
        private:
            static constexpr unsigned a = 16807;        // 7^5
            static constexpr unsigned m = 2147483647;   // 2^31 - 1

            static constexpr unsigned s = MetaRandomGenerator<N - 1>::value;
            static constexpr unsigned lo = a * (s & 0xFFFF);                // Multiply lower 16 bits by 16807
            static constexpr unsigned hi = a * (s >> 16);                   // Multiply higher 16 bits by 16807
            static constexpr unsigned lo2 = lo + ((hi & 0x7FFF) << 16);     // Combine lower 15 bits of hi with lo's upper bits
            static constexpr unsigned hi2 = hi >> 15;                       // Discard lower 15 bits of hi
            static constexpr unsigned lo3 = lo2 + hi;

        public:
            static constexpr unsigned max = m;
            static constexpr unsigned value = lo3 > m ? lo3 - m : lo3;
        };

        template<>
        struct MetaRandomGenerator<0>
        {
            static constexpr unsigned value = seed;
        };

        // Note: A bias is introduced by the modulo operation.
        // However, I do believe it is neglictable in this case (M is far lower than 2^31 - 1)

        template<int N, int M>
        struct MetaRandom
        {
            static const int value = MetaRandomGenerator<N + 1>::value % M;
        };








        // Represents an obfuscated string, parametrized with an algorithm number N, a list of indexes Indexes and a key Key

        template<int N, char Key, typename Indexes>
        struct MetaString;

        // Partial specialization with a list of indexes I, a key K and algorithm N = 0
        // Each character is encrypted (XOR) with the same key

        template<char K, int... I>
        struct MetaString<0, K, Indexes<I...>>
        {
            // Constructor. Evaluated at compile time.
            constexpr ALWAYS_INLINE MetaString(const char* str)
                : key_{ K }, buffer_{ encrypt(str[I], K)... } { }

            // Runtime decryption. Most of the time, inlined
            inline const char* decrypt()
            {
                for (size_t i = 0; i < sizeof...(I); ++i)
                    buffer_[i] = decrypt(buffer_[i]);
                buffer_[sizeof...(I)] = 0;
                return const_cast<const char*>(buffer_);
            }

        private:
            // Encrypt / decrypt a character of the original string with the key
            constexpr char key() const { return key_; }
            constexpr char ALWAYS_INLINE encrypt(char c, int k) const { return c ^ k; }
            constexpr char decrypt(char c) const { return encrypt(c, key()); }

            volatile int key_; // key. "volatile" is important to avoid uncontrolled over-optimization by the compiler
            volatile char buffer_[sizeof...(I) + 1]; // Buffer to store the encrypted string + terminating null byte
        };

        // Partial specialization with a list of indexes I, a key K and algorithm N = 1
        // Each character is encrypted (XOR) with an incremented key.

        template<char K, int... I>
        struct MetaString<1, K, Indexes<I...>>
        {
            // Constructor. Evaluated at compile time.
            constexpr ALWAYS_INLINE MetaString(const char* str)
                : key_(K), buffer_{ encrypt(str[I], I)... } { }

            // Runtime decryption. Most of the time, inlined
            inline const char* decrypt()
            {
                for (size_t i = 0; i < sizeof...(I); ++i)
                    buffer_[i] = decrypt(buffer_[i], i);
                buffer_[sizeof...(I)] = 0;
                return const_cast<const char*>(buffer_);
            }

        private:
            // Encrypt / decrypt a character of the original string with the key
            constexpr char key(size_t position) const { return static_cast<char>(key_ + position); }
            constexpr char ALWAYS_INLINE encrypt(char c, size_t position) const { return c ^ key(position); }
            constexpr char decrypt(char c, size_t position) const { return encrypt(c, position); }

            volatile int key_; // key. "volatile" is important to avoid uncontrolled over-optimization by the compiler
            volatile char buffer_[sizeof...(I) + 1]; // Buffer to store the encrypted string + terminating null byte
        };

        // Partial specialization with a list of indexes I, a key K and algorithm N = 2
        // Shift the value of each character and does not store the key. It is only used at compile-time.

        template<char K, int... I>
        struct MetaString<2, K, Indexes<I...>>
        {
            // Constructor. Evaluated at compile time. Key is *not* stored
            constexpr ALWAYS_INLINE MetaString(const char* str)
                : buffer_{ encrypt(str[I])..., 0 } { }

            // Runtime decryption. Most of the time, inlined
            inline const char* decrypt()
            {
                for (size_t i = 0; i < sizeof...(I); ++i)
                    buffer_[i] = decrypt(buffer_[i]);
                return const_cast<const char*>(buffer_);
            }

        private:
            // Encrypt / decrypt a character of the original string with the key
            // Be sure that the encryption key is never 0.
            constexpr char key(char key) const { return 1 + (key % 13); }
            constexpr char ALWAYS_INLINE encrypt(char c) const { return c + key(K); }
            constexpr char decrypt(char c) const { return c - key(K); }

            // Buffer to store the encrypted string + terminating null byte. Key is not stored
            volatile char buffer_[sizeof...(I) + 1];
        };

        // Helper to generate a key
        template<int N>
        struct MetaRandomChar
        {
            // Use 0x7F as maximum value since most of the time, char is signed (we have however 1 bit less of randomness)
            static const char value = static_cast<char>(1 + MetaRandom<N, 0x7F - 1>::value);
        };
    }

    namespace String_Enstone
    {
        // Compile-time generator for random numbers
        template<int N>
        struct RandomValueGenerator
        {
        private:
            static constexpr int s = RandomValueGenerator<N - 1>::value;
            static constexpr unsigned int lo = 16807 * (s & 0xFFFF);
            static constexpr unsigned int hi = 16807 * (s >> 16);
            static constexpr unsigned int res = lo + ((hi & 0x7FFF) << 16) + hi;

        public:
            static constexpr int value = res > INT_MAX ? res - INT_MAX : res;
        };

        template<>
        struct RandomValueGenerator<0>
        {
            // Convert compilation time to a seed if N is equal to 0
            static constexpr int value =
                __TIME__[7] - '0' +
                (__TIME__[6] - '0') * 10 +
                (__TIME__[4] - '0') * 60 +
                (__TIME__[3] - '0') * 600 +
                (__TIME__[1] - '0') * 3600 +
                (__TIME__[0] - '0') * 36000;
        };

        template<int n, int min, int max>
        struct RandomValue
        {
            static constexpr int value = min + RandomValueGenerator<n + 1>::value % (max - min);
        };


        // Compile-time generator for list of indexes (0, 1, 2, ...)
        template <int...>
        struct IndexList
        {
        };

        template <typename	List, int Right>
        struct Append;

        template <int... Left, int Right>
        struct Append<IndexList<Left...>, Right>
        {
            typedef IndexList<Left..., Right> Result;
        };

        template <int N>
        struct MakeIndexes
        {
            typedef typename Append<typename MakeIndexes<N - 1>::Result, N - 1>::Result Result;
        };

        template <>
        struct MakeIndexes<0>
        {
            typedef IndexList<> Result;
        };


        // Run-time decryption function | Reversed engineered from CCAPI by @jordywastaken
        static std::string DecryptString(const char* in, int len, int key)
        {
            std::string out = std::string(len, '\0');

            char previous = 0;
            for (int i = len - 1; i >= 0; --i)
            {
                char v16 = i + key + previous;
                previous = out[i] = v16 ^ in[i];
            }
            return out;
        }


        // Compile-time string encryption class
        template <int key, int len, typename List>
        struct Encrypted;

        template <int _key, int _len, int... I>
        struct Encrypted<_key, _len, IndexList<I...> >
        {
            char data[_len];

            // Compile-time constructor
            constexpr inline Encrypted(const char* const Str)
                : data{ encrypt(Str[I], (I < _len - 1) ? Str[I + 1] : 0, I, _key)... } {}

            constexpr char encrypt(char current, char next, int i, int key)
            {
                return current ^ char((i + key + next));
            }
        };
    }

    namespace Integer_MetaRand
    {
        // Meta Random Integer
        // https://github.com/cr-lupin/metarand

        constexpr char meta_rand_inits[] = __TIME__;
        const int meta_rand_seed = (meta_rand_inits[0] - '0') * 100000 + (meta_rand_inits[1] - '0') * 10000 +
            (meta_rand_inits[3] - '0') * 1000 + (meta_rand_inits[4] - '0') * 100 + (meta_rand_inits[6] - '0') * 10 + meta_rand_inits[7] - '0';

        template<typename E>
        struct CMetaUInt_eval
        {
            typedef typename E::type type;
        };

        template<typename E>
        struct CMetaUInt_init
        {
            typedef E type;
        };

        template<typename Engine>
        struct CMetaUInt_Random
        {
            //static const uint_fast32_t value = seed;
            //typedef linear_congruential_engine<uint_fast32_t, value> type;
            typedef typename CMetaUInt_init<Engine>::type type;
            static const decltype(type::value) value = type::value;
        };

        template<typename R>
        struct CMetaUInt_Next
        {
            typedef typename CMetaUInt_eval<R>::type type;
            static const decltype(type::value) value = type::value;
            //static const uint_fast32_t value = linear_congruential_engine<R>::value; //next random val
        };


        //--------------- linear_congruential_engine ---------------------

        template<typename UIntType,
            UIntType seed = meta_rand_seed,
            UIntType a = 16807,
            UIntType c = 0,
            UIntType m = 2147483647>
        struct linear_congruential_engine
        {
            static const UIntType value = seed;
            static const UIntType maxvalue = m - 1;
        };

        template<typename UIntType, UIntType seed, UIntType a, UIntType c, UIntType m>
        struct CMetaUInt_eval<linear_congruential_engine<UIntType, seed, a, c, m>>
        {
            static const UIntType value = (a * seed + c) % m;
            typedef linear_congruential_engine<
                UIntType,
                (a* seed + c) % m,
                a,
                c,
                m
            > type;
        };

        template<typename UIntType,
            UIntType seed,
            UIntType a,
            UIntType c,
            UIntType m>
        struct CMetaUInt_init<linear_congruential_engine<UIntType, seed, a, c, m>>
        {
            typedef typename CMetaUInt_eval<linear_congruential_engine<UIntType, seed, a, c, m>>::type type;
            static const UIntType value = type::value;
        };

        // ----------------- fib_engine ----------------------------

        template<typename UIntType,
            UIntType a = 0,
            UIntType b = 1>
        struct fib_engine
        {
            static const UIntType value = a;
        };

        template<typename UIntType, UIntType a, UIntType b>
        struct CMetaUInt_eval<fib_engine<UIntType, a, b> >
        {
            static const UIntType value = a + b;
            typedef fib_engine<
                UIntType,
                b,
                value
            > type;
        };

        // ------------------------ substract_with_carry --------------

        template<typename UIntType,
            UIntType r,
            UIntType s,
            UIntType m,
            UIntType seed = meta_rand_seed>
        struct substract_with_carry_engine
        {
        };

        template<typename UIntType,
            UIntType r,
            UIntType s,
            UIntType m,
            UIntType res,
            UIntType... vals>
        struct substract_with_carry_impl
        {
            static const UIntType value = res;

            template< unsigned int N, UIntType v, UIntType... vs >
            struct extract
            {
                const static UIntType value = extract<N - 1, vs...>::value;
            };

            template< UIntType v, UIntType... vs  >
            struct extract<0, v, vs...>
            {
                const static UIntType value = v;
            };

            template< unsigned int N >
            struct get
            {
                const static UIntType value = extract<N, vals...>::value;
            };

            //debug
            template< UIntType v, UIntType... vs>
            struct print_aux
            {
                static void print()
                {
                    //printf("0x%X ", v);
                    print_aux<vs...>::print();
                }
            };

            template< UIntType v>
            struct print_aux<v>
            {
                static void print()
                {
                    //printf("0x%X\n", v);
                }
            };

            struct print
            {
                static void dump()
                {
                    print_aux<vals...>::print();
                }
            };

        };

        template<typename UIntType,
            UIntType r,
            UIntType s,
            UIntType m,
            typename FillRnd, unsigned int cnt, UIntType... vals>
        struct fillrnd
        {
            typedef typename CMetaUInt_Next<FillRnd>::type RND;
            typedef typename fillrnd<UIntType,
                r, s, m,
                RND, cnt - 1, vals..., RND::value >::type type;
        };

        template<typename UIntType,
            UIntType r,
            UIntType s,
            UIntType m,
            typename FillRnd, UIntType... vals>
        struct fillrnd<UIntType, r, s, m, FillRnd, 0, vals...>
        {
            typedef substract_with_carry_impl< UIntType,
                r, s, m, 0, //0 is dummy result
                vals...> type;
        };

        template<typename UIntType,
            UIntType r,
            UIntType s,
            UIntType m,
            UIntType seed>
        struct CMetaUInt_init<substract_with_carry_engine<UIntType, r, s, m, seed>>
        {
            typedef typename fillrnd<
                UIntType,
                r, s, m,
                typename CMetaUInt_Random<linear_congruential_engine<uint_fast32_t, seed>>::type,
                r
            >::type type;
        };

        template<typename UIntType,
            UIntType r,
            UIntType s,
            UIntType m,
            UIntType res,
            UIntType val,
            UIntType... vals>
        struct CMetaUInt_eval<substract_with_carry_impl<UIntType, r, s, m, res, val, vals...>>
        {
            //typedef seq<UIntType, vals...> X;
            typedef substract_with_carry_impl<UIntType, r, s, m, res, val, vals...> X;
            static const UIntType value = (X::template get<0>::value - X:: template get<r - s>::value);
            //static const UIntType value = val + 1;
            typedef substract_with_carry_impl<
                UIntType,
                r, s, m,
                value,
                vals...,
                value
            > type;
        };

        // ------------------------------- Bernoulli

        template<typename Engine, int N, int D, bool val = false>
        struct Bernoulli
        {
            static const bool value = val;
        };

        template<typename Engine, int N, int D, bool b>
        struct CMetaUInt_eval<Bernoulli<Engine, N, D, b>>
        {
            typedef typename CMetaUInt_Next<Engine>::type tmptype;
            static const bool value = static_cast<double>(tmptype::value) / tmptype::maxvalue < static_cast<double>(N) / D;
            typedef Bernoulli<tmptype, N, D, value> type;

        };

        template<int cnt, typename R>
        struct CMetaUInt_PrintRandoms
        {
            static void print()
            {
                typedef typename CMetaUInt_Next<R>::type RND;
                //printf("0x%X ", RND::value);
                CMetaUInt_PrintRandoms<cnt - 1, RND >::print();
            }
        };

        template<typename R>
        struct CMetaUInt_PrintRandoms<0, R>
        {
            static void print()
            {
                //printf("0x%X \n", CMetaUInt_Next<R>::value);
            }
        };


        typedef CMetaUInt_init<substract_with_carry_engine<unsigned int, 10, 2, 1>>::type X;
        typedef CMetaUInt_Next<X>::type RandomCompileTimeInteger1;
        typedef CMetaUInt_Next<RandomCompileTimeInteger1>::type RandomCompileTimeInteger2;
        typedef CMetaUInt_Next<RandomCompileTimeInteger2>::type RandomCompileTimeInteger3;
        typedef CMetaUInt_Next<RandomCompileTimeInteger3>::type RandomCompileTimeInteger4;
        typedef CMetaUInt_Next<RandomCompileTimeInteger4>::type RandomCompileTimeInteger5;
        typedef CMetaUInt_Next<RandomCompileTimeInteger5>::type RandomCompileTimeInteger6;
        typedef CMetaUInt_Next<RandomCompileTimeInteger6>::type RandomCompileTimeInteger7;
        typedef CMetaUInt_Next<RandomCompileTimeInteger7>::type RandomCompileTimeInteger8;

    }



}



/************* VxObfuscator *******************/
// Disable warning 69 'integer conversion resulted in truncation'
#pragma diag_suppress 69

// Compile-time hashing macro, hash values changes using the first pseudorandom number in sequence
#define vxHASH(Str) (uint32_t)(pobf::String_Vx::vxCplConstantify<pobf::String_Vx::vxCplHash(Str)>::Value ^ pobf::String_Vx::vxCplConstantify<pobf::String_Vx::vxCplRandom(1)>::Value)

// Compile-time string encryption macro
// NOTE(Roulette): In disassembly PPC64 it uses memcpy and a small for loop to decrypt the string
#define vxENCRYPT(Str) (pobf::String_Vx::vxCplEncryptedString<pobf::String_Vx::vxCplIndexes<sizeof(Str) - 1>::Result>(Str).decrypt())

#define ENCRYPTSTRV1(str) vxENCRYPT(str)



/************* ADVobfuscator *******************/

// Prefix notation
// NOTE(Roulette): In disassembly PPC64 it does not use memcpy but rather individual instructions like "li r3 0x48" for each byte which increases code size (sprx size increase for each use case)
#define ADV_DEF_OBFUSCATED(str) pobf::String_ADVobfuscator::MetaString<pobf::String_ADVobfuscator::MetaRandom<__COUNTER__, 3>::value, pobf::String_ADVobfuscator::MetaRandomChar<__COUNTER__>::value, pobf::String_ADVobfuscator::Make_Indexes<sizeof(str) - 1>::type>(str)
#define ADV_OBFUSCATED_STR(str) (ADV_DEF_OBFUSCATED(str).decrypt())

#define ENCRYPTSTRV2(str) ADV_OBFUSCATED_STR(str)



/************* EnstoneObfuscator *******************/

// Disable warning 1724 'routine is both "inline" and "noinline"'
#pragma diag_suppress 1724

// NOTE(Roulette): This string encryption "may" be slightly slower since it uses std::string. Need to profile it to actually see results.
#define EnstoneStringEncrypt(str) []() __attribute__((noinline)) \
    { \
        constexpr int key = pobf::String_Enstone::RandomValue<__COUNTER__, -200, 200>::value; \
        static constexpr auto encrypted = pobf::String_Enstone::Encrypted<key, sizeof(str), pobf::String_Enstone::MakeIndexes<sizeof(str)>::Result>(str); \
        return pobf::String_Enstone::DecryptString(encrypted.data, sizeof(str), key); \
    }().c_str()

#define ENCRYPTSTRV3(str) EnstoneStringEncrypt(str)


#endif // __POWEROBFUSCATOR_H__ 